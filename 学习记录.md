| 学习内容                      | 第一次学习时间  | 第二次学习时间 | 第三次学习时间 |
| ----------------------------- | --------------- | -------------- | -------------- |
| SpringBoot编程思想            | 2020年3月31号晚 | 2020年4月8日晚 |                |
| 十种经典算法                  | 2020年4月1日    |                |                |
| 漫画算法                      | 2020年3月31日   |                |                |
| spring官方文档-32 Cache       | 2020年3月20日   |                |                |
| spring官方文档-2 introduction | 2020年3月25日   |                |                |
| spring源码分析                | 2020年3月25日   |                |                |
| Spring Cloud学习              | 2020年1月20日   |                |                |
| Spring Cloud Alibaba 学习     | 2020年4月1日    |                |                |
| Ehcache                       | 2020年3月20日   |                |                |
| servlet3.0新特性              | 2020年3月20日   |                |                |
| 源码juc学习                   | 2020年1月20日   | 2020年4月25日  |                |
| java集合                      | 2020年1月20日   |                |                |
| java8学习                     | 2020年1月20日   |                |                |
| jvm                           | 2020年1月20日   |                |                |
| 设计模式                      | 2020年1月20日   |                |                |
| netty实战                     | 2020年1月20日   |                |                |
| dubbo官网学习                 | 2020年2月20日   |                |                |
| Nacos学习                     | 2020年4月2日    |                |                |
| i18n学习                      | 2020年4月10日   | 2020年4月15日  |                |

### [Java多线程基础（一）——线程与锁](https://segmentfault.com/a/1190000015555859)

#### 一、线程的基本概念

##### 1.1 单线程

##### 1.2 多线程

#### 二、线程的基本操作

#### 2.1 创建

1. 继承java.lang.Thread

2. 实现Runnable接口

#### 2.2 暂停

#### 三、线程的状态转移

- 当创建一个Thread子类或实现Runnable接口类的实例时，线程进入【初始】状态；

- 调用实例的start方法后，线程进入【可执行】状态；
- 系统会在某一时刻自动调度处于【可执行】状态的线程，被调度的线程会调用run方法，进入【执行中】状态；
- 线程执行完run方法后，进入【结束】状态；
- 处于【结束】状态的线程，在某一时刻，会被JVM垃圾回收；
- 处于【执行中】状态的线程，若调用了Thread.yield方法，会回到【可执行】状态，等待再次被调度；
- 处于【执行中】状态的线程，若调用了wait方法，会进入wait set并一直等待，直到被其它线程通过notify、notifyAll、interrupt方法唤醒；
- 处于【执行中】状态的线程，若调用了Thread.sleep方法，会进入【Sleep】状态，无法继续向下执行。当sleep时间结束或被interrupt时，会回到【可执行状态】；
- 处于【执行中】状态的线程，若遇到阻塞I/O操作，也会停止等待I/O完成，然后回到【可执行状态】；

